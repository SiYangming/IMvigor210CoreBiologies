##' Filtering a count matrix to remove low read genes
##'
##' This function takes a count matrix and removes genes that don't reach a minimum namer of reads in a certain number of samples.
##' @param m raw count matrix (genes are rows, columns are samples)
##' @param minSamples numeric; minimum number of samples in which CPM threshold has to be reached; defaults to a tenth of available samples
##' @param minCpm numeric; the minimum counts per million (CPM) that has to be reached
##' @return filtered count matrix
##' @author Dorothee Nickles
##' @export
filterForVoom <- function(m, minSamples=ncol(m)/10, minCpm=0.25) {
  tmp <- edgeR::cpm(m)
  sel <- apply(tmp, 1, function(x) {
    sum(x >= minCpm) >= minSamples
  })
  return(m[sel,])
}

##' Normalize a count matrix using limma::voom
##'
##' This function takes a count matrix, calculates either DESeq sizeFactors or EdgeR normFactors and normalizes counts using limma::voom
##' @param m raw count matrix (genes are rows, columns are samples)
##' @param DESeq logical; if set to FALSE (default), edgeR normFactors will used for normalization; otherwise, DEseq sizeFactors will be used
##' @return normalized count matrix
##' @author Dorothee Nickles
##' @export
mySimpleVoom <- function(m, DESeq=FALSE){
  if (DESeq) {
    nf <- DESeq2::estimateSizeFactorsForMatrix(m)
    v <- limma::voom(m,
      lib.size = median(colSums(m)) * nf)
  } else {
    dge <- edgeR::DGEList(m)
    dge <- edgeR::calcNormFactors(dge)
    v <- limma::voom(dge)
  }
  return(v)
}

##' Filter and normalize a count matrix
##'
##' This wrapper function combines filtering out genes with low reads in a number of samples (recommended for limma:voom) with normalization
##' @param m raw count matrix (genes are rows, columns are samples)
##' @param minSamples numeric; minimum number of samples in which CPM threshold has to be reached; defaults to a tenth of available samples
##' @param minCpm numeric; the minimum counts per million (CPM) that has to be reached
##' @param DESeq logical; if set to FALSE (default), edgeR normFactors will used for normalization; otherwise, DEseq sizeFactors will be used
##' @return filtered and normalized count matrix
##' @author Dorothee Nickles
##' @export
filterNvoom <- function(m, minSamples=ncol(m)/10, minCpm=0.25, DESeq=FALSE) {
  m_sel <- filterForVoom(m,
    minSamples,
    minCpm)
  v <- mySimpleVoom(m_sel,
    DESeq=DESeq)
  return(v)
}

##' Calculate score across genes and samples
##'
##' This wrapper function combines filtering out genes with low reads in a number of samples (recommended for limma:voom) with normalization
##' @param gm normalized count matrix; rows are all genes in the signature that shall be summarized into one score; columns are samples
##' @param summarizationFunction character vector defining whether signature scores shall be based on principal component 1 ("PC", default) or z-scores (other value)
##' @return numeric vector of length ncol(gm); a score summarizing the rows of gm
##' @author Dorothee Nickles
##' @export
gsScore <- function(gm, summarizationFunction="PC") {
  if (summarizationFunction == "PC") {
    pc <- prcomp(t(gm),
      retx=TRUE)
    gss <- pc$x[,1] * sign(cor(pc$x[,1], colMeans(gm)))
  } else {
    gss <- colMeans(gm)
  }
  return(gss)
}

##' Perform a likelihood ratio test for association between trait and variable of interest
##'
##' This convenience function extracts the likelihood ratio test p-value from an ANOVA output on a nested model.
##' @param gene numeric vector; variable of interest (dependent variable)
##' @param response vector of same length as gene; trait of interest (independent variable)
##' @return numeric; likelihood ratio test p-value indicating whether there is a significant association between trait and variable of interest
##' @author Dorothee Nickles
##' @export
getPfromAnova <- function(gene, response) {
  fit0 <- lm(gene ~ 1)
  fit1 <- lm(gene ~ response)
  pval <- anova(fit0, fit1)[["Pr(>F)"]][2]
  pval <- as.numeric(sprintf("%.2e", pval))
  return(pval)
}

##' Extract hazard ratio and confidence intervals from a coxph object
##'
##' Convenience function to extract hazard ratio and confidence intervals from a coxph object,
##' as generated by a call to coxph(), comparing survival times between two groups
##' @param coxphData coxph object; coxphData <- coxph(Surv(TTE, Cens) ~ group, data=df)
##' @author Dorothee Nickles
##' @export
##' @import survival
getHRandCIfromCoxph <- function(coxphData) {

  stopifnot(is(coxphData, "coxph"))

  tmp <- cbind(
                summary(coxphData)$coef[,
                                    c("Pr(>|z|)", "exp(coef)"), 
                                    drop=FALSE],
                summary(coxphData)$conf[,
                                    c("lower .95", "upper .95"), 
                                    drop=FALSE]
              )
  colnames(tmp) <- c("P","HR","CIl0.95","CIu0.95")
  return(tmp)

}

##' Convert numeric p-values into significance levels
##'
##' This convenience function converts a numeric p-value into "***" annotation, indicating significance level
##' @param pval numeric vector; p-value(s) to be converted
##' @return character vector; "***" = P < 0.001, "**" = P < 0.01, "*" = P < 0.05, "." < P < 0.1, "n.s." = not significant
##' @author Dorothee Nickles
##' @export
pLevel <- function(pval) {
  ifelse(pval < 0.001, "***",
          ifelse(pval < 0.01, "**",
            ifelse(pval < 0.05, "*",
              ifelse(pval < 0.1, ".", "n.s."))))
}

##' Combine data from all mutation matrices
##'
##' Given an \code{\linkS4class{NChannelSet}} containing FMOne mutation data, check all assay data mutation matrices.
##' If a non-empty string is found in one or more, return TRUE.
##'
##' @param ncs The \code{\linkS4class{NChannelSet}} object.
##'
##' @return A logical matrix with row and column names matching the input object,
##' suitable for direct addition as additional assay data.
##'
##' Assay data matrices are assumed to contain a non-empty string if a mutation
##' was found, and a zero-character string if nothing was found.
##' @author Richard Bourgon
##' @export
any_mutation <- function( ncs ) {
  if ( !is( ncs, "eSet" ) ) stop( "Only suitable for eSet objects" )
  is_mutation <- sapply( assayData( ncs ), function( x ) as.vector( x ) != "" )
  matrix(
    rowSums( is_mutation ) > 0,
    nrow( ncs ),
    ncol( ncs ),
    dimnames = list( featureNames( ncs ), sampleNames( ncs ) )
    )
}

##' Cap values in a numeric matrix at a specific value
##'
##' This convenience function sets an absolute maximum a value cannot exceed in a numeric count matrix
##' @param m numeric matrix
##' @param max.z numeric vector of length 1; maximum/minimum number at which data will be truncated
##' @return capped numeric matrix
##' @author Thomas Sandmann
##' @export
limitRange <- function( m, max.z = 3){
  m[ m > max.z] <- max.z
  m[ m < -max.z] <- -max.z
  return(m)
}

##' Custom version of Kaplan Meier plot
##'
##' Custom display of survival data, including plotting lines for median survival and adding number at risk
##' @param survFit survfit object; survfit(Surv(TTE, Cens) ~ group, data=df)
##' @param survDiff surfdiff object; survdiff(Surv(TTE, Cens) ~ group, data=df)
##' @param diff.factor factor, the grouping factor used for survfit call
##' @param main character; main title for plot
##' @param cols character vector; colors, default to darkgreen, darkmagenta, cyan4, darkorange, darkred
##' @param xLab character; x-axis label for plot
##' @param yLab character; y-axis label for plot
##' @param ltypes numeric vector; line types (lty) for plot
##' @param plotMedian logical; shall the median survival for each group be plotted
##' @param pval type of p-value computed, either "logrank" or "coxph" (the latter
##' can only be computed on two groups)
##' @param coxphData coxph object; coxphData <- coxph(Surv(TTE, Cens) ~ group, data=df)
##' @param legPos legend position for legend()
##' @param mar plotting margins
##' @param plot.nrisk logical; shall number of samples for each group and time point
##' be plotted underneath graph
##' @param nrisk.interval numeric; spacing of time intervals for which number of samples
##'                is given; defaults to 2
##' @param timemark logical; if set to TRUE (default), censoring marks are added to survival curves
##' @param lwd line width for survival curves
##' @param cexMedian numeric; relative size of font for median survival times
##' @param cexLegend numeric; relative size of legend font
##' @param ... other arguments passed to plot.survfit
##' @author Yuanyuan Xiao, Dorothee Nickles
##' @export
##' @import survival
plotSurvival2 <- function(survFit,
                          survDiff,
                          diff.factor,
                          main,
                          cols,
                          xLab="PFS (months)",
                          yLab="Probability of survival",
                          ltypes=1,
                          plotMedian=FALSE,
                          pval=c("logrank", "coxph", "none"),
                          coxphData,
                          legPos="topright",
                          mar=c(12,9,3,2),
                          plot.nrisk=FALSE,
                          nrisk.interval=2,
                          timemark=TRUE,
                          lwd=2,
                          cexMedian=0.75,
                          cexLegend=0.8,
                          ...) {


      stopifnot(is(survFit, "survfit"))
      stopifnot(is(survDiff, "survdiff"))
      stopifnot(is(diff.factor, "factor"))

      ## simple checks to decrease chance that fitted data used indeed
      ## same data and same calls
      fitCall <- as.character(survFit$call)
      diffCall <- as.character(survDiff$call)
      stopifnot(fitCall[2] == diffCall[2])
      stopifnot(fitCall[3] == diffCall[3])

      group.labels <- levels(diff.factor)

      ## setting colors
      if (missing(cols)) {
        cols <- c("darkgreen", "darkmagenta", "cyan4", "darkorange", "darkred")[1:nlevels(diff.factor)]
      }
      stopifnot(length(cols) == length(group.labels))

      ## computing number of samples at each time point
      if (plot.nrisk) {
        time.pt <- seq(0, max(survFit$time), nrisk.interval)
        ix = 0
        n.risk = c()
        for (kk in 1:(length(survFit$strata))) {
          fit.n.risk = survFit$n.risk[(ix+1) : (ix + survFit$strata[kk])]
          fit.time = survFit$time[(ix+1) : (ix + survFit$strata[kk])]
          tmp = findInterval(time.pt, fit.time)
          n.risk=rbind(n.risk,
                        ifelse(tmp < length(fit.time), fit.n.risk[tmp+1], 0)
                        )
          ix = ix + survFit$strata[kk]
        }
        dimnames(n.risk)[[2]] = time.pt

        if (mar[1]<4+length(group.labels)) {
          mar[1] <- 4+length(group.labels)
        }
        org.mar <- par()$mar
        par(mar=mar)
      }

      ## plot curves and axes
      plot(survFit,
            xlab=xLab,
            lwd=lwd,
            lty=ltypes,
            col=cols,
            ylab=yLab,
            main=main,
            axes=FALSE,
            mark.time=timemark,
            ...)
      box()
      axis(1,
          at=seq(0, max(survFit$time), nrisk.interval),
          seq(0, max(survFit$time), nrisk.interval)
          )
      axis(2,
          at=seq(0, max(survFit$time), 0.1),
          seq(0, max(survFit$time), 0.1),
          las=2)
      abline(h=0,
            col="darkgrey")

      ## add the survival medians
      if (plotMedian) {
          median.surv <- summary(survFit)$table[,"median"]
          wMed <- which(!is.na(median.surv))
          median.surv <- median.surv[!is.na(median.surv)]
          median.surv <- round(median.surv, digits=2)
          for (i in 1:length(median.surv)) {
            lines(x=rep(median.surv[i], 6),
                  y=seq(0,0.5,0.1),
                  lty=2,
                  col="darkgrey")
            lines(x=seq(0, median.surv[i], length.out=6),
                  y=rep(0.5,6),
                  lty=2,
                  col="darkgrey")
            text(x=median.surv[i],
                  y=-0.02,
                  labels=median.surv[i],
                  cex=cexMedian,
                  col=cols[wMed][i])
          }
      }

      ## add the number of samples underneath plot
      if (plot.nrisk) {
        for (i in 1:length(group.labels)) {
          mtext(side=1,
                at=-1.7,
                line=i+3.5,
                text=group.labels[i],
                col=cols[i],
                adj=1,
                cex=0.6)
          mtext(side=1,
                at=time.pt,
                line=i+3.5,
                text=n.risk[i,],
                col=cols[i],
                cex=0.8)
        }
      }

      ## compute statistics
      if (pval == "logrank") {
        pval <- round(1 - pchisq(survDiff$chisq, length(survDiff$n) - 1),
                      digits=3)
        group.labels <- c(group.labels,
                          paste("log rank pval:", pval))
      }
      if (pval == "coxph") {
          stopifnot(!missing(coxphData))
          stopifnot(is(coxphData, "coxph"))
          coxCall <- as.vector(coxphData$formula)
          stopifnot(fitCall[2] == coxCall)
          stopifnot(sum(survFit$n) == coxphData$n)
          stopifnot(length(group.labels) == 2)

          tmp <- round(getHRandCIfromCoxph(coxphData),
                      digits=4)
          group.labels <- c(group.labels,
                    paste("pval:", tmp[1,"P"]),
                    paste("HR:",
                        paste0(tmp[1,"HR"], " (", tmp[1,"CIl0.95"], ";",
                            tmp[1,"CIu0.95"], ")")))
      }

      ## plot legend
      legend(legPos,
            group.labels,
            lwd=2,
            col=c(cols, "white", "white"),
            lty=ltypes,
            legend=group.labels,
            bty="n",
            cex=cexLegend)

      ## reset mar that was changed to allow adding numbers underneath plot
      if (plot.nrisk) {
        par(mar=org.mar)
      }

}

##' Convert human gene symbols to mouse gene symbols using biomaRt.
##' Our gene signatures consist of human gene symbols, so in order to score mouse gene expression
##' samples for gene signatures, we first need to convert the human gene symbols to mouse gene symbols.
##'
##' @param x character vector for human gene symbols
##' @return matrix; N by 2 matrix where the first column is the input human gene symbols, and the second column is the corresponding mouse gene symbols. One human gene can map to multiple mouse genes, and also multiple human genes can map to one mouse gene.
##' @author Yasin Senbabaoglu
##' @export
##' @import biomaRt
human2mouse <- function(x){
  human <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
  mouse <- useMart("ensembl", dataset = "mmusculus_gene_ensembl")

  g <- getLDS(attributes = c("hgnc_symbol"), filters = "hgnc_symbol", values = x , mart = human, attributesL = c("mgi_symbol"), martL = mouse, uniqueRows=T)

  # Print the first 6 genes found to the screen
  print("First six:")
  print(g[1:6,2])
  return(g)
}

##' Score mouse gene expression samples for signatures.
##'
##' @param x gene expression matrix; normalized (CPM, TPM, RPKM, FPKM, etc.) but not standardized across samples; samples in columns, genes in rows
##' @param glist named list object where each element is a character vector and comprises of a gene signature
##' @param gprofile character vector; gene symbols for all genes in x (in the same order as in x)
##' @param log.inside boolean; should x be log-transformed inside the function?, log-transformation is recommended, can be done inside or outside the function
##' @param print.sig.names boolean; should the signature names be printed on the screen as they are being scored?
##' @param lowExpressionCutoff numeric; low expression cutoff for the genes in a signature. If this is defined, genes with maximum expression value (maximum across samples) less than this cutoff are removed from the signature.
##' @param conversionDB N by 2 matrix; output of human2mouse(); conversion database showing the mapping from human to mouse gene symbols
##' @return matrix; scores for signatures; signatures in rows, samples in columns
##' @author Yasin Senbabaoglu
##' @export
score.signatures.DB.mouse <- function(x,glist,gprofile,conversionDB,log.inside=FALSE,print.sig.names=TRUE,lowExpressionCutoff = NULL){
  # For the mouse version, x has to be unstandardized because MAD selection will operate on
  # pre-standardized values

  # log2 if desired
  if(log.inside) x <- log2(x+1)

  scoreMat <- matrix(NA,ncol=ncol(x),nrow=length(glist))
  for(k in 1:length(glist)){
    if(print.sig.names)    print(names(glist)[k])
    this <- glist[[k]]
    # Create matrix with score vectors
    mat <- matrix4signature(x,this,gprofile,conversionDB,lowExpressionCutoff)
    # Score with mean Z (They're already Z)
    scoreMat[k,] <- colMeans(mat)
  }

  rownames(scoreMat) <- names(glist)
  colnames(scoreMat) <- colnames(x)

  scoreMat
}


##' Auxiliary function that prepares a gene by sample matrix for the computation of signature scores.
##' If a human gene has multiple orthologs in mouse, then the mouse gene with maximum MAD (median absolute deviation) across the samples is used.
##'
##' @param x gene expression matrix; normalized (CPM, TPM, RPKM, FPKM, etc.) but not standardized across samples; samples in columns, genes in rows
##' @param genelist named list object where each element is a character vector and comprises of a gene signature
##' @param gprofile character vector; gene symbols for all genes in x (in the same order as in x)
##' @param lowExpressionCutoff numeric; low expression cutoff for the genes in a signature. If this is defined, genes with maximum expression value (maximum across samples) less than this cutoff are removed from the signature.
##' @param conversionDB N by 2 matrix; output of human2mouse(); conversion database showing the mapping from human to mouse gene symbols
##' @return matrix; gene expression matrix with genes in rows and samples in columns
##' @author Yasin Senbabaoglu
##' @export
matrix4signature <- function(x,genelist,gprofile,conversionDB,lowExpressionCutoff = NULL){

  xsd <- t(scale(t(x)))   # standardize
  tmp <- c() # the matrix to give score vector for this signature
  used.genes <- c()
  for(j in 1:length(genelist)){
    w <- which(conversionDB$HGNC.symbol == genelist[j])
    # if w is empty, then skip
    if(length(w) == 0){
      warning(genelist[j]," not found in conversion DB")
      next
    }
    mgi.list <- conversionDB$MGI.symbol[w]
    mx <- match(mgi.list,gprofile)
    # if mx is all NAs, then skip
    if(all(is.na(mx))){
      warning(genelist[j]," not found in data matrix")
      next
    }
    clean.mx <- mx[!is.na(mx)]
    subx <- rbind(x[clean.mx,],rep(0,ncol(x)))
    rownames(subx) <- c(mgi.list[!is.na(mx)],"Empty.row")
    wmax <- which.max(apply(subx,1,stats::mad)) # Max is chosen from non-standardized data

    # If the new gene was already added to the TMP matrix, skip to the next gene
    new.gene <- rownames(subx)[wmax]
    if(new.gene %in% used.genes) next
    # update used.genes
    used.genes <- c(used.genes,new.gene)

    if(wmax == nrow(subx)) stop("Error with wmax in score.signatures.DB.mouse") # can't be the last one because it is artificial zeroes to make the code work

    # Low expression filter
    if(!is.null(lowExpressionCutoff)){
      expvec <- x[clean.mx[wmax],]
      if(max(expvec) < lowExpressionCutoff){
        warning(new.gene," is low expressed, removed from score")
        next
      }
    }

    # Multiple orthologs
    if(nrow(subx) > 2) cat(new.gene, "has max MAD (",signif(mad(subx[wmax,]),3),") among orthologs\n")
    # now add row to tmp matrix
    tmp <- rbind(tmp,xsd[clean.mx[wmax],])
  }
  tmp
}
